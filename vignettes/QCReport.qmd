---
title: "FragPipe TMT QC"
author: "Witold Wolski"
execute:
  echo: false
  cache: true
output:
  pdf_document:
    keep_tex: true
    latex_engine: pdflatex
    toc: true
    number_sections: false
  bookdown::pdf_document2:
    keep_tex: true
    latex_engine: pdflatex
    toc: true
    number_sections: false
    global_numbering: false
  html_document:
    toc: true
    number_sections: false
    global_numbering: false

editor: source
editor_options: 
  chunk_output_type: console
params:
  wd: ""
  psm: ""
  fasta: ""
  workunit: ""
  projectid: ""
---



```{r setupglobal}
#| include: false


knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6,
  dpi = 300
)

# Set working directory for analysis
wd <- if(params$wd == ""){"inst/PTM_example_analysis_v2"} else {params$wd}

wd <- here::here(wd)

dir.create(wd, recursive = TRUE, showWarnings = FALSE)
knitr::opts_knit$set(root.dir = wd)

# Load required libraries
suppressPackageStartupMessages({
  library(prolfquapp)
  library(prophosqua)
  library(tidyverse)
  library(ggseqlogo)
  library(here)
  library(ggplot2)
  library(prolfquapp)

})
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

```

```{r}
#| echo: false
#| warning: false
#| message: false
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r a1getthedata}
zip_url  <- "https://gitlab.bfabric.org/wolski/ptm_example/-/archive/main/ptm_example-main.zip"
destfile <- "ptm_example-main.zip"

# Download, unzip and delete
download.file(zip_url, destfile, mode = "wb")
unzip(destfile, exdir = ".")
unlink(destfile)
do_dea <- TRUE

```

# Configuration

This section shows the key parameters used for this QC analysis. The report can be parameterized to analyze different datasets by providing custom file paths and identifiers.

```{r readYaml}

# Set default values if parameters are empty
default_params <- list(
  workunit = if(params$workunit == "") "1234" else params$workunit,
  projectid = if(params$projectid == "") "4321" else params$projectid,
  psm = if(params$psm == "") "ptm_example-main/qc_example_data/QCmini/psm.tsv" else params$psm,
  fasta = if(params$fasta == "") "ptm_example-main/qc_example_data/fgcz_3702_UP000006548_AraUniprot_1spg_d_20231024.fasta" else params$fasta
)

pathtoZip <- list(psm = default_params$psm, fasta = default_params$fasta)

addinfo <- data.frame(name = c("workunit_id", "project_id", "datasetname", "fastasequence"),
                      value =  c(default_params$workunit, default_params$projectid, pathtoZip$psm, pathtoZip$fasta
                        ))

knitr::kable(addinfo, caption = "project information")
```

QC will only use the first psm file.

```{r}
fpsm <- pathtoZip$psm
cat("using :", fpsm,"\n")
```

# FASTA Database Summary

The FASTA database contains the protein sequences used for peptide identification. Understanding the composition of your search database is crucial for interpreting identification results and assessing potential biases.

**Key metrics to evaluate:** 

- **Database size**: Typical sizes vary by organism:
  - Human: ~20,000 proteins
  - Mouse: ~22,000 proteins
  - Yeast: ~6,000 proteins
  - E. coli: ~4,400 proteins
  - Arabidopsis: ~27,000 protein coding genes, ~35,000 proteins
- **Decoy sequences**: Reverse sequences (REV\_) are used to estimate false discovery rates
- **Amino acid composition**: Should reflect the expected composition of your sample organism

```{r analyseFASTA}
fasta <- prozor::readPeptideFasta(pathtoZip$fasta)
fastaWithRev <- length(fasta)
fasta <- fasta[!grepl("REV_", names(fasta))]
fastaNoRev <- length(fasta)
x <- prozor::make_fasta_summary(fasta,as_string = TRUE)

```

The FASTA database has `r fastaWithRev` sequences including decoys, and `r fastaNoRev` without decoys. 
The amino acid frequency distribution below shows the composition of your search database, which should be consistent with the expected proteome composition.

```{r printFASTA}
cat(x)

```

# Data Processing Overview

This analysis processes peptide-spectrum matches (PSMs) from FragPipe with specific quality filters to ensure reliable quantification.

**Quality filters applied:** 

- **Peptide Prophet probability \> 0.9**: Ensures high confidence identifications 
- **Abundance threshold \> 0**: Removes PSMs without quantitative information 
- **Purity threshold = 0**: No isolation purity filtering (all PSMs included)

```{r readDatafromZIP}
xx <- readr::read_tsv(pathtoZip$psm)
nrSpectraAll <- xx$Spectrum |> unique() |> length()

#debug(prolfquapp::tidy_FragPipe_psm)

psm <- prolfquapp::tidy_FragPipe_psm(pathtoZip$psm,
                                   purity_threshold = 0,
                                   PeptideProphetProb = 0.9,
                                   abundance_threshold = 0,
                                   aggregate = FALSE)
psm <- dplyr::inner_join(psm$data, psm$nrPeptides_exp, by = "Protein")
nrowPSM <- nrow(psm)
nrSpectraPP09 <- psm$Spectrum |> unique() |> length()

```

For this analysis we are using all PSM (Spectra) reported in the psm.tsv file with a peptide prophet probability greater than $0.9$, and an abundance value in any of the channels greater then $0$. No other filtering is enabled. This reduces the number of PSM from `r nrSpectraAll` to `r nrSpectraPP09`.

The reduction in PSM count reflects the stringency of our quality filters. A typical reduction of 1-10$\%$ is expected and indicates proper quality control.

```{r setupPROLFQUA}
stopifnot(nrow(psm) == nrowPSM)

fasta_annot <- get_annot_from_fasta(pathtoZip$fasta)
psm <- dplyr::left_join(psm, fasta_annot, by = c(Protein = "fasta.id"), multiple = "all")

stopifnot(nrow(psm) == nrowPSM)

prot_annot <- prolfquapp::dataset_protein_annot(
  psm,
  c("protein_Id" = "Protein"),
  protein_annot = "fasta.header",
  more_columns = "nrPeptides")

psm$qValue <- 1 - psm$Probability

atable <- prolfqua::AnalysisTableAnnotation$new()
atable$ident_Score = "Probability"
atable$ident_qValue = "qValue"
atable$fileName = "channel"

atable$opt_rt = "Retention"
atable$opt_mz = "psmcharge"

atable$hierarchy[["protein_Id"]] <- c("Protein")
atable$hierarchy[["peptide_Id"]] <- c("Peptide")
atable$hierarchy[["mod_peptide_Id"]] <- c("Modified.Peptide","Assigned.Modifications")
atable$hierarchy[["precursor"]] <- c("Modified.Peptide","Assigned.Modifications", "Charge")
atable$hierarchy[["Spectrum"]] <- c("Spectrum")

atable$factors[["experiment"]] <- "experiment"
atable$set_response("abundance")

psm$experiment <- "QC"
psm$psmcharge <- psm$Charge
config <- prolfqua::AnalysisConfiguration$new(atable)

adata <- prolfqua::setup_analysis(psm, config)

lfqdata <- prolfqua::LFQData$new(adata, config)

allmods <- lfqdata$data |> dplyr::select(mod_peptide_Id, Spectrum) |> dplyr::distinct()
allmods <- allmods |> dplyr::group_by(mod_peptide_Id) |> dplyr::summarize(n = dplyr::n()) |> dplyr::ungroup()
allmods <- allmods |> tidyr::separate(mod_peptide_Id, into = c("modSeq", "Assigned.Modifications"), sep = "~")
allmods <- allmods |> tidyr::separate_longer_delim("Assigned.Modifications", delim = ",")
allmods <- allmods |> dplyr::mutate(Assigned.Modifications = trimws(Assigned.Modifications))
allmods <- allmods |> dplyr::mutate(Modification = gsub("^[0-9]+","", Assigned.Modifications))
allmods$n1 <- 1

```

# Identification Summary

These metrics provide an overview of the depth and breadth of your proteomic analysis. Higher numbers generally indicate better sample preparation and instrument performance.

**Understanding the hierarchy:** 

- **Proteins**: Unique protein groups identified 
- **Peptides**: Unique peptide sequences (without modifications) 
- **Peptidoforms**: Unique peptides with specific modifications 
- **Precursors**: Unique peptide-charge state combinations 
- **PSMs**: Total peptide-spectrum matches

```{r identSummaryTable}
knitr::kable(lfqdata$hierarchy_counts(), caption = "Table: Nr of proteins, peptides, peptidoforms, precursors, spectrum peptide matches overall.")

```

The ratio between these levels can indicate data quality:

- **PSMs/Peptides ratio**: Higher ratios suggest good reproducibility 
- **Peptidoforms/Peptides ratio**: Indicates the extent of post-translational modifications 
- **Peptides/Proteins ratio**: Reflects proteolytic efficiency and peptide diversity

```{r identSummaryPlot, fig.height=10, fig.cap="Figure: Number of proteins, peptides, peptidoforms, ions and precursor per channel."}
st <- lfqdata$get_Summariser()
st$plot_hierarchy_counts_sample()
```

This plot shows the identification counts across different TMT channels. Ideally, all channels should show similar identification numbers, indicating consistent sample preparation and labeling efficiency.

```{r identSummaryTable2}
knitr::kable(st$hierarchy_counts_sample(), caption = "Table: Nr of proteins, peptides, peptidoforms, precursors, spectrum peptide matches per channel.")
```

**Quality indicators:** 

- **Consistent counts across channels**: Good sample preparation 
- **Large variations**: May indicate labeling issues or sample degradation 
- **Outlier channels**: Should be investigated for technical problems

# Modifications Summary

Post-translational modifications (PTMs) and chemical modifications provide insights into sample treatment and biological state. TMT labeling introduces specific modifications that should be monitored for labeling efficiency.

**Key modifications to monitor:** 

- **TMT labels**: N-term(229.1629), K(229.1629) for TMT10plex 
- **Oxidation**: M(15.9949) - common artifact 
- **Carbamylation**: N-term/K modifications from urea treatment

```{r modSummary}
tx <- allmods$Modification |> table()
knitr::kable(tx, caption = "Number and type of modifications observed in the data.")
```

```{r modSummaryPlot,fig.cap = "Number and type of modification observed in the data."}
par(mar = c(10,5,2,2))
barplot(tx, las = 2)
```

The modification landscape reflects both intentional chemical treatments (TMT labeling) and unintentional modifications (oxidation, deamidation). High numbers of TMT modifications indicate successful labeling.

# Labelling Efficiency

TMT labeling efficiency is critical for accurate quantification. Incomplete labeling leads to quantitative errors and reduced dynamic range.

**Monitoring labeling efficiency:** 

- **N-terminal labeling**: Should approach 100% for most peptides 
- **Lysine labeling**: Should be \>95% for high-quality samples 
- **Unlabeled peptides**: May co-elute and interfere with quantification

## N-term

N-terminal labeling efficiency is typically very high (\>95%) as it's kinetically favored.

### Peptides

```{r LE}

xA <- allmods |> dplyr::select(modSeq, n, n1) |> dplyr::distinct()
xN <- allmods |> dplyr::filter(Modification == "N-term(229.1629)" | Modification == "N-term(304.2071)")
xN <- xN |> dplyr::select(modSeq, n, n1) |> dplyr::distinct()

nrNtermMod <- xN$n1 |> sum()
nrPeptides <- xA$n1 |> sum()

```

-   Total number of peptides : `r nrPeptides`
-   Number of peptides with modified N-term : `r nrNtermMod`
-   Percent peptides with modified N-term: `r round(nrNtermMod/nrPeptides*100)` %

**Expected range**: 95-100%. Values below 95% may indicate: 

- Suboptimal labeling conditions 
- Sample degradation 
- Buffer incompatibility

### PSM's

```{r LEPSM}
nrNtermModPSM <- xN$n |> sum()
nrPSM <- xA$n |> sum()

```

-   Total number of PSMs : `r nrPSM`
-   Number of PSMs with modified N-term : `r nrNtermModPSM`
-   Percent PSMs with modified N-term: `r round(nrNtermModPSM/nrPSM*100)` %

PSM-level statistics weight peptides by their identification frequency, providing insight into the most abundant species in your sample.

## Lysine Modification

Lysine labeling is more challenging than N-terminal labeling and is more sensitive to reaction conditions.

### Peptides

```{r LELysine}
xL <- allmods |> dplyr::filter(Modification == "K(229.1629)" | Modification == "K(304.2071)")
xL <- xL |> dplyr::select(.data$modSeq, n, n1) |> dplyr::distinct()
xN <- allmods |> dplyr::select(.data$modSeq, n, n1) |> dplyr::distinct()
xN <- xN |> dplyr::filter(grepl("K", modSeq))

```

-   Total number of peptides with Lysine: `r xN$n1 |> sum()`
-   Number of peptides with modified Lysine residues : `r xL$n1 |> sum()`
-   Percent peptides with modified Lysine residues: `r round((xL$n1 |> sum())/(xN$n1 |> sum())*100)` %

**Expected range**: 95-99%. Lower values may indicate: 

- Insufficient reagent concentration 
- Competing reactions (e.g., formaldehyde crosslinking) 
- pH optimization needed

### PSM's with Lysine

-   Total number of PSMs with Lysine: `r xN$n |> sum()`
-   Number of PSMs with modified Lysine residues : `r xL$n |> sum()`
-   Percent PSMs with modified Lysine residues: `r round((xL$n |> sum())/(xN$n |> sum())*100)` %



```{r LEResiduesLysine}
xN <- allmods |> dplyr::select(.data$modSeq, .data$n, .data$n1) |> dplyr::distinct()
nrK <-  xN |> dplyr::mutate(nrK = stringr::str_count(modSeq,"K"))

nrKmod <- allmods |> dplyr::filter(Modification == "K(229.1629)" | Modification == "K(304.2071)")
nrKmod <- nrKmod |> dplyr::group_by(.data$modSeq , n , n1) |> dplyr::summarize(nrKmod = dplyr::n(), .groups="drop") |> dplyr::ungroup()
```

### Peptidoforms

```{r }
nrLys <- (nrK$nrK * nrK$n1) |> sum()
nrLysMod <- (nrKmod$nrKmod * nrKmod$n1) |> sum()
prcLysMod <- round( ( (nrKmod$nrKmod * nrKmod$n1) |> sum()) / ((nrK$nrK * nrK$n1) |> sum()) * 100)

```

-   Total number of Lysine residues: `r  nrLys`
-   Number of modified Lysine residues : `r nrLysMod`
-   Percent modified Lysine residues: `r prcLysMod` %

### Total number of Lysine residues in PSM's

-   Total number of Lysine residues: `r sum(nrK$nrK * nrK$n)`
-   Number of modified Lysine residues : `r sum(nrKmod$nrKmod * nrKmod$n)`
-   Percent modified Lysine residues when taking number of PSMs into account: `r round( sum(nrKmod$nrKmod * nrKmod$n) / sum(nrK$nrK * nrK$n) * 100 )` %


# Quantitative information per channel

TMT quantification relies on consistent labeling and equal loading across channels. These plots help identify technical issues that could bias quantitative comparisons.

**Quality indicators:** 

- **Similar total abundances**: Good sample preparation and loading 
- **Outlier channels**: May indicate pipetting errors or sample loss 
- **Systematic patterns**: Could suggest batch effects or labeling issues

```{r totalQuant, fig.cap = "Total abundance per channel (Sum of all abundances)."}

xx <- lfqdata$data
totalPerChannel <- xx |> dplyr::group_by(!!rlang::sym(lfqdata$config$table$sampleName) ) |>
  dplyr::summarize(totalAbundance = sum(!!rlang::sym(lfqdata$response()), na.rm = TRUE))

totalPerChannel |> ggplot2::ggplot(ggplot2::aes(x = sampleName, y = totalAbundance)) + 
  ggplot2::geom_bar(stat = "identity", position = "dodge", colour = "black", fill = "white") + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust = 1))

```

Total abundance reflects both sample amount and ionization efficiency. Large variations (\>2-fold) should be investigated.

```{r relativeQuant, fig.cap = "Ralative to chanell 126 total abundance per chanel."}
nudgeval = 0.1
p126 <- totalPerChannel |> dplyr::filter(grepl("126",sampleName) )
totalPerChannel$norm126abundance <- totalPerChannel$totalAbundance / p126$totalAbundance

totalPerChannel |> ggplot2::ggplot(ggplot2::aes(x = sampleName, y = norm126abundance)) + 
  ggplot2::geom_bar(stat = "identity", position = "dodge", colour = "black", fill = "white") + 
  ggplot2::geom_text(ggplot2::aes(label = round(.data$norm126abundance,2)), nudge_y = nudgeval, angle = 65) +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# TODO add numbers to bars and table.

```

Normalization to a reference channel (126) helps identify systematic biases. Values should typically be within 0.5-2.0 fold of the reference.

```{r densityQuant, fig.cap="Density of abundance values per channel."}
pl <- lfqdata$get_Plotter()
pl$intensity_distribution_density()
```

The abundance distribution should be similar across channels. Shifted distributions may indicate: - Unequal sample loading - Different sample complexity - Technical artifacts in specific channels

# Missed cleavage

Missed cleavage analysis provides insights into proteolytic efficiency and sample quality. Excessive missed cleavages can reduce identification rates and affect quantification accuracy.

Missed cleavage site: Is a residue after which trypsin should have cleaved but did not.

**Factors affecting missed cleavages:** 

- **Protein denaturation**: Incomplete unfolding reduces accessibility 
- **Digestion time/temperature**: Insufficient conditions lead to incomplete digestion 
- **Enzyme activity**: Old or inhibited trypsin reduces efficiency 
- **Chemical modifications**: Modified residues may resist cleavage

To determine the number of missed cleavages we compute: - The number of all potential cleavage sites (i.e., number of K or R residues) - The number of actual cleavage sites (K or R at peptide C-terminus) - Modified residues that may resist cleavage

## Missed Lysine residues

We compute the total number of K residues, and the number of K cleavage sites (nr of potential cleavage sites). Then we compute the number of K at the C-term

```{r missedAtLysine}
modSeqD <- allmods |> dplyr::select(modSeq, n) |> dplyr::distinct() 
patterns <- list(R = "K", termR = "K$", termRmod = "K\\[[0-9]+\\]$", termR_termRmod = "K$|K\\[[0-9]+\\]$", Rmod = "K\\[[0-9]+\\]")
modSeqD$n1 <- 1


match_count <- function(p, data, count_col = "n") {
  nr <- stringr::str_count(data$modSeq, pattern = p) 
  nr <- (nr * data[[count_col]]) |> sum()
  return(nr)
}

r <- lapply(patterns, match_count, modSeqD, count_col = "n")
```

-   The number of K residues `r r$R`
-   The number of unmodified K at C term `r r$termR`
-   The number of modified K at C term `r r$termRmod`
-   The number of any K at C term `r r$termR_termRmod`
-   The number of any modified K: `r r$Rmod`
-   Missed cleavage sites : number of K residues - number of any K at C term = `r r$R - r$termR_termRmod`,
-   and in % of number of K residues : `r round((r$R - r$termR_termRmod)/r$R *100)`

**Expected range**: 5-15% missed cleavages are typical. Higher rates may indicate: 

- Incomplete protein denaturation 
- Insufficient digestion time
- Trypsin inhibitors present 
- High protein concentration

## Missed Arginine residues

```{r missedAtArginine}
patterns <- list(R = "R", termR = "R$", termRmod = "R\\[[0-9]+\\]$", termR_termRmod = "R$|R\\[[0-9]+\\]$", Rmod = "R\\[[0-9]+\\]")
modSeqD$n1 <- 1
r <- lapply(patterns, match_count, modSeqD, count_col = "n")

```

-   The number of R residues `r r$R`
-   The number of unmodified R at C term `r r$termR`
-   The number of modified R at C term `r r$termRmod`
-   The number of any R at C term `r r$termR_termRmod`
-   The number of any modified R: `r r$Rmod`
-   Missed cleavage sites : number of R residues - number of any R at C term = `r r$R - r$termR_termRmod`,
-   and in % of number of R residues : `r round((r$R - r$termR_termRmod)/r$R *100)`

Arginine cleavage is generally more efficient than lysine cleavage. Similar missed cleavage rates between K and R suggest consistent digestion conditions.

# Session Info

```{r sessionInfo}
pander::pander(sessionInfo())
```
